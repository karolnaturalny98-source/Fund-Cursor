[
  {
    "category": "FOUC/Theme",
    "severity": "high",
    "file": "app/layout.tsx",
    "line": 43,
    "issue": "Brak natychmiastowej klasy motywu na <html> powoduje biały błysk przy pierwszym załadowaniu. ThemeProvider jest kliencki i wykonuje się po hydration, co powoduje widoczny flash białego tła.",
    "fix": "Dodaj inline script w <head> ustawiający klasę motywu przed hydration React. Script powinien odczytać localStorage/sessionStorage i ustawić klasę 'dark' lub 'light' na <html> natychmiast.",
    "snippet": "// W app/layout.tsx, przed <html>:\n<script\n  dangerouslySetInnerHTML={{\n    __html: `\n      (function() {\n        try {\n          const theme = localStorage.getItem('theme') || 'system';\n          const isDark = theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);\n          document.documentElement.classList.toggle('dark', isDark);\n        } catch (e) {}\n      })();\n    `,\n  }}\n/>"
  },
  {
    "category": "FOUC/Theme",
    "severity": "medium",
    "file": "app/globals.css",
    "line": 392,
    "issue": "Body ma złożony gradient background, który może powodować miganie przy zmianie motywu. Brak natychmiastowego tła dla light mode może powodować białe błyski.",
    "fix": "Upewnij się, że body ma solidne tło dla obu motywów przed zastosowaniem gradientu. Rozważ użycie CSS custom properties dla gradientu zamiast hardcoded wartości.",
    "snippet": "// W globals.css, upewnij się że body ma:\nbody {\n  @apply min-h-screen bg-background text-foreground antialiased;\n  background: hsl(var(--background)); /* fallback */\n  background: radial-gradient(circle at 30% 10%, hsl(156 72% 14% / 0.2), hsl(220 20% 5%) 80%), hsl(var(--background));\n}"
  },
  {
    "category": "Bundle",
    "severity": "high",
    "file": "components/editor/rich-text-editor.tsx",
    "line": 1,
    "issue": "Tiptap editor (~150KB) jest importowany synchronicznie. Powinien być ładowany dynamicznie tylko gdy użytkownik otworzy formularz wymagający edytora.",
    "fix": "Użyj dynamic import z ssr: false. Edytor powinien być ładowany tylko w komponentach admina, które go używają.",
    "snippet": "// W komponentach używających RichTextEditor:\nimport dynamic from 'next/dynamic';\nconst RichTextEditor = dynamic(\n  () => import('@/components/editor/rich-text-editor').then(mod => ({ default: mod.RichTextEditor })),\n  { ssr: false, loading: () => <div className=\"h-[300px] animate-pulse rounded-lg bg-muted\" /> }\n);"
  },
  {
    "category": "Bundle",
    "severity": "high",
    "file": "components/companies/payouts-charts.tsx",
    "line": 24,
    "issue": "Recharts (~200KB) jest importowany synchronicznie. Komponent jest już używany z dynamic import w niektórych miejscach, ale sam komponent importuje recharts bezpośrednio.",
    "fix": "Komponent jest już ładowany dynamicznie w app/firmy/[slug]/page.tsx, ale można rozważyć dalszą optymalizację - lazy load tylko gdy tab jest aktywny.",
    "snippet": "// Komponent już jest dynamiczny, ale można dodać Suspense boundary:\n// W app/firmy/[slug]/page.tsx:\n<Suspense fallback={<ChartSkeleton />}>\n  <PayoutsCharts company={company} />\n</Suspense>"
  },
  {
    "category": "Bundle",
    "severity": "medium",
    "file": "components/companies/leverage-tiers-card.tsx",
    "line": 26,
    "issue": "Recharts jest importowany synchronicznie w komponencie, który może nie być widoczny od razu. Powinien być ładowany dynamicznie.",
    "fix": "Użyj dynamic import dla tego komponentu lub przenieś import recharts do osobnego modułu ładowanego dynamicznie.",
    "snippet": "// W komponencie nadrzędnym:\nimport dynamic from 'next/dynamic';\nconst LeverageTiersCard = dynamic(\n  () => import('@/components/companies/leverage-tiers-card').then(mod => ({ default: mod.LeverageTiersCard })),\n  { ssr: false, loading: () => <CardSkeleton /> }\n);"
  },
  {
    "category": "Bundle",
    "severity": "medium",
    "file": "components/Aurora.tsx",
    "line": 4,
    "issue": "OGL (~50KB) jest importowany synchronicznie. Aurora jest używana w wielu miejscach i może być ładowana dynamicznie, ponieważ jest efektem wizualnym niekrytycznym.",
    "fix": "Rozważ dynamic import dla Aurora lub lazy load tylko gdy komponent jest widoczny (IntersectionObserver).",
    "snippet": "// W komponentach używających Aurora:\nimport dynamic from 'next/dynamic';\nconst Aurora = dynamic(() => import('@/components/Aurora'), { ssr: false });"
  },
  {
    "category": "Bundle",
    "severity": "low",
    "file": "lib/animations.ts",
    "line": 1,
    "issue": "GSAP (~40KB) może być używany tylko w niektórych komponentach. Sprawdź czy wszystkie komponenty rzeczywiście go potrzebują.",
    "fix": "Jeśli GSAP jest używany tylko w kilku komponentach, rozważ dynamic import lub zastąpienie prostszymi animacjami CSS.",
    "snippet": "// Sprawdź użycie GSAP:\ngrep -r \"from ['\\\"]gsap['\\\"]\" components/"
  },
  {
    "category": "Image",
    "severity": "medium",
    "file": "components/rankings/rankings-explorer.tsx",
    "line": 1330,
    "issue": "Brak atrybutu `sizes` dla Image w CompanyAvatar. Next.js nie może optymalizować obrazu bez informacji o rozmiarze.",
    "fix": "Dodaj `sizes=\"44px\"` do komponentu Image, ponieważ logo ma stały rozmiar 44x44px.",
    "snippet": "<Image\n  src={logoUrl}\n  alt={name}\n  width={44}\n  height={44}\n  sizes=\"44px\"\n  priority={priority}\n  className=\"...\"\n/>"
  },
  {
    "category": "Image",
    "severity": "low",
    "file": "components/companies/company-media.tsx",
    "line": 71,
    "issue": "Brak atrybutu `sizes` dla Image w CompanyMedia. Obrazy mają width={96} height={96}, ale brakuje sizes dla responsywności.",
    "fix": "Dodaj `sizes=\"(max-width: 768px) 96px, 96px\"` lub po prostu `sizes=\"96px\"` jeśli rozmiar jest stały.",
    "snippet": "<Image\n  src={item.imageUrl}\n  alt={item.title}\n  width={96}\n  height={96}\n  sizes=\"96px\"\n  className=\"...\"\n  loading=\"lazy\"\n/>"
  },
  {
    "category": "Hydration",
    "severity": "low",
    "file": "app/providers/currency-client-provider.tsx",
    "line": 60,
    "issue": "localStorage jest odczytywany w useEffect, co może powodować krótki flash domyślnej waluty przed załadowaniem zapisanej wartości. To może powodować hydration mismatch jeśli SSR renderuje inną walutę niż localStorage.",
    "fix": "Upewnij się, że initialCurrency z SSR jest zawsze używany jako fallback. Rozważ użycie cookie zamiast localStorage dla initial render (SSR-friendly).",
    "snippet": "// Obecna implementacja jest OK, ale upewnij się że initialCurrency jest zawsze używany jako fallback:\n// W useEffect:\nconst stored = window.localStorage.getItem(CURRENCY_STORAGE_KEY);\nif (stored) {\n  const normalized = ensureSupportedCurrency(stored, initialCurrency);\n  setCurrencyState(normalized);\n} // Jeśli nie ma stored, używa initialCurrency z props (SSR)"
  },
  {
    "category": "Hydration",
    "severity": "low",
    "file": "components/admin/admin-content.tsx",
    "line": 26,
    "issue": "window.innerWidth jest używany w useEffect do wykrywania desktop. Może powodować hydration mismatch jeśli SSR renderuje inną wersję niż klient.",
    "fix": "Użyj media query hook lub CSS media queries zamiast JavaScript. Jeśli musisz użyć JS, upewnij się że initial state jest zgodny z SSR.",
    "snippet": "// Rozważ użycie CSS:\n// W CSS: @media (min-width: 1024px) { ... }\n// Lub hook:\nconst [isDesktop, setIsDesktop] = useState(false);\nuseEffect(() => {\n  setIsDesktop(window.innerWidth >= 1024);\n  // ...\n}, []);"
  },
  {
    "category": "Re-render",
    "severity": "medium",
    "file": "components/analysis/analysis-layout.tsx",
    "line": 1,
    "issue": "Cały AnalysisLayout jest Client Component, ale większość danych pochodzi z SSR. Można przenieść część do Server Component i przekazać tylko interaktywne części jako Client Components.",
    "fix": "Rozdziel na Server Component (dane, layout) i Client Component (tabs, interakcje). Tylko Tabs i dynamiczne wykresy powinny być klienckie.",
    "snippet": "// Server Component:\nexport default async function AnalysisLayout({ companies, ... }) {\n  return (\n    <div>\n      <AnalysisTabsClient companies={companies} ... />\n    </div>\n  );\n}\n\n// Client Component tylko dla tabs:\n\"use client\";\nexport function AnalysisTabsClient({ companies, ... }) { ... }"
  },
  {
    "category": "Re-render",
    "severity": "low",
    "file": "components/companies/companies-page-client.tsx",
    "line": 73,
    "issue": "window.setTimeout jest używany bez cleanup w niektórych miejscach. Może powodować memory leaks i niepotrzebne re-rendery.",
    "fix": "Upewnij się, że wszystkie setTimeout mają cleanup w return z useEffect.",
    "snippet": "useEffect(() => {\n  const handler = window.setTimeout(() => { ... }, delay);\n  return () => window.clearTimeout(handler);\n}, [dependencies]);"
  },
  {
    "category": "Tailwind",
    "severity": "low",
    "file": "components/affiliate/affiliate-benefits.tsx",
    "line": 67,
    "issue": "Inline style używany dla CSS variable --delay. Można przenieść do Tailwind arbitralnych wartości lub CSS utility class.",
    "fix": "Rozważ użycie Tailwind arbitrary values lub CSS utility class zamiast inline style.",
    "snippet": "// Zamiast:\nstyle={{ \"--delay\": `${index * 100}ms` }}\n// Użyj:\nclassName=\"[--delay:calc(var(--index)*100ms)]\"\n// Lub CSS utility class w globals.css"
  },
  {
    "category": "Performance",
    "severity": "medium",
    "file": "components/Aurora.tsx",
    "line": 154,
    "issue": "Aurora używa requestAnimationFrame w pętli bez przerwy. Może powodować wysokie zużycie CPU/GPU, szczególnie na słabszych urządzeniach. Brak optymalizacji dla urządzeń mobilnych.",
    "fix": "Rozważ użycie IntersectionObserver aby zatrzymać animację gdy komponent nie jest widoczny. Dodaj również optymalizację dla prefers-reduced-motion.",
    "snippet": "useEffect(() => {\n  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n  if (prefersReducedMotion) return;\n  \n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (!entry.isIntersecting) {\n        cancelAnimationFrame(animateId);\n      } else {\n        animateId = requestAnimationFrame(update);\n      }\n    });\n  });\n  observer.observe(ctn);\n  return () => observer.disconnect();\n}, []);"
  },
  {
    "category": "Performance",
    "severity": "low",
    "file": "app/globals.css",
    "line": 229,
    "issue": "Gradient-button utility ma bardzo długie transition-duration (0.5s) dla wielu właściwości. Może powodować opóźnienia w interakcjach.",
    "fix": "Rozważ skrócenie transition-duration do 0.2-0.3s dla lepszej responsywności UI.",
    "snippet": "// W globals.css, zmień:\ntransition: --pos-x 0.3s, --pos-y 0.3s, ...; /* zamiast 0.5s */"
  },
  {
    "category": "Code Splitting",
    "severity": "medium",
    "file": "components/rankings/rankings-explorer.tsx",
    "line": 13,
    "issue": "RankingsCharts jest ładowany dynamicznie, ale RankingsExplorer jest bardzo duży (~1700 linii). Rozważ dalszy podział na mniejsze komponenty.",
    "fix": "Rozdziel RankingsExplorer na mniejsze komponenty (filtry, tabela, mobile list) i ładowaj je dynamicznie tylko gdy są potrzebne.",
    "snippet": "// Przykład:\nconst RankingsFilters = dynamic(() => import('./rankings-filters'), { ssr: false });\nconst RankingsTable = dynamic(() => import('./rankings-table'), { ssr: false });"
  },
  {
    "category": "Accessibility",
    "severity": "low",
    "file": "components/Aurora.tsx",
    "line": 120,
    "issue": "Aurora nie respektuje prefers-reduced-motion. Użytkownicy z wrażliwością na ruch mogą odczuwać dyskomfort.",
    "fix": "Dodaj sprawdzenie prefers-reduced-motion i wyłącz animację jeśli użytkownik preferuje redukcję ruchu.",
    "snippet": "useEffect(() => {\n  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n  if (prefersReducedMotion) return;\n  // ... reszta animacji\n}, []);"
  },
  {
    "category": "Fonts",
    "severity": "low",
    "file": "app/layout.tsx",
    "line": 15,
    "issue": "Geist i Geist_Mono są ładowane z Google Fonts. Brakuje font-display: swap w konfiguracji next/font, co może powodować FOIT (Flash of Invisible Text).",
    "fix": "Next.js automatycznie używa font-display: swap, ale upewnij się że czcionki są preloadowane. Rozważ dodanie preload dla krytycznych czcionek.",
    "snippet": "// Next.js automatycznie optymalizuje, ale można dodać:\nconst geistSans = Geist({\n  variable: \"--font-geist-sans\",\n  subsets: [\"latin\"],\n  display: \"swap\", // explicit (choć domyślne)\n});"
  }
]

